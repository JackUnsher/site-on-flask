---
description: 
globs: 
alwaysApply: true
---
# ПРАВИЛА АВТОНОМНОЙ РАБОТЫ ДЛЯ CLAUDE 3.7 SONNET

## МЕТАПРИНЦИПЫ
- КЛЮЧЕВОЙ ПРИНЦИП: Максимально избегай уточняющих вопросов к пользователю
- Самостоятельно анализируй код, инфраструктуру и контекст перед запросом уточнений
- Предлагай конкретные решения вместо вопросов о предпочтениях
- Следуй принципу разумного предположения (reasonable assumption) вместо прямого вопроса
- Если вынужден делать предположение, явно укажи это один раз в конце ответа
- Всегда придерживайся точного соответствия дизайну из Figma, если не указано иное
- Используй существующий код проекта как источник конвенций и стандартов
- Анализируй зависимости и файловую структуру для понимания архитектуры
- Предлагай инновационные решения, когда это явно улучшает функциональность

## СТРАТЕГИИ АВТОНОМНОГО ПРИНЯТИЯ РЕШЕНИЙ
- При неполном запросе анализируй последние коммиты, открытые файлы и контекст разговора
- Если неясно, какой стиль кода использовать, ищи похожие файлы в проекте и следуй их стилю
- Вместо вопросов о выборе библиотек проверяй существующие зависимости в package.json/requirements.txt
- Если нужна новая зависимость, предложи её, объяснив преимущества (не спрашивай разрешения)
- Для интеграций с внешними API ищи уже используемые паттерны в коде
- При необходимости принятия решения о структуре используй существующие конвенции проекта
- Вместо вопросов о предпочтительном подходе, примени наиболее современный и соответствующий кодовой базе
- Перед реализацией сложной логики, проанализируй существующие решения аналогичных задач в проекте

## САМОСТОЯТЕЛЬНЫЙ СБОР ИНФОРМАЦИИ
- Перед реализацией функционала исследуй:
  * Существующие файлы конфигурации для определения окружения
  * Структуру проекта для понимания архитектуры
  * Зависимости для определения доступных инструментов
  * Шаблоны использования библиотек в проекте
- При необходимости доступа к Figma самостоятельно:
  * Проверь наличие конфигурации MCP плагина в проекте 
  * Изучи историю разговора на предмет ссылок на Figma
  * Поищи константы стилей в CSS/SCSS файлах для выявления дизайн-системы
- Если пользователь не указал конкретный язык программирования:
  * Определи его по файловой структуре и расширениям
  * Проверь инфраструктурные файлы (.gitignore, docker-compose.yml и т.д.)
  * Ищи инструкции по запуску в README или package.json/script

## ОБЩИЕ ПРАВИЛА PYTHON
- Следуй PEP 8 для форматирования кода
- Используй типизацию (аннотации типов)
- Избегай глобальных переменных
- Применяй контекстные менеджеры (with) для управления ресурсами
- Используй f-строки вместо .format() и % форматирования
- Предпочитай list comprehension для простых операций
- Автоматически добавляй в requirements.txt новые зависимости
- Документируй публичные функции и методы через docstrings
- Предлагай прогрессивные решения, соответствующие Python 3.10+

## ПРАВИЛА ДЛЯ FLASK
### Автономное определение структуры
- Анализируй существующие файлы для определения используемой архитектуры
- Автоматически определяй и следуй паттерну (Factory/Singleton/Blueprint)
- При создании новых маршрутов группируй их по логическому назначению
- Используй существующие соглашения для именования URL и переменных

### Автоматизация реализации
- Придерживайся используемых ORM-паттернов (SQLAlchemy/Peewee)
- Определяй нужные миграции на основе изменений моделей
- Автоматически внедряй документирование новых маршрутов API
- Поддерживай разделение бизнес-логики и представления
- Интегрируй новый код с существующими системами аутентификации

### Безопасность и производительность
- Автоматически внедряй CSRF-защиту для форм
- Всегда параметризуй SQL-запросы
- Индексируй поля с частыми запросами
- Кэшируй тяжелые вычислительные операции
- Выстраивай обработку ошибок согласно существующим паттернам

## ПРАВИЛА ДЛЯ TELEGRAM БОТОВ
### Автономное определение архитектуры
- Анализируй существующий код для определения используемой библиотеки (aiogram/python-telegram-bot)
- Определяй модель получения обновлений (webhook/polling) по настройкам
- Автоматически интегрируй новый код с существующими обработчиками
- Следуй установленным паттернам работы с состояниями

### Работа с API и данными
- Автоматически определяй метод хранения состояний из кода
- Используй асинхронные операции для неблокирующей обработки
- Внедряй обработку ошибок API Telegram во все запросы
- Придерживайся существующих паттернов для медиа-контента
- Соблюдай установленный стиль оформления сообщений и клавиатур

### Оптимизация и масштабирование
- Определяй потенциальные узкие места (rate limits, блокирующие операции)
- Автоматически внедряй throttling на основе API-лимитов
- Структурируй обработчики по частоте и приоритету вызовов
- Используй background tasks для длительных операций
- Автоматически добавляй логирование для критических операций

## ПРАВИЛА ДЛЯ РАБОТЫ С FIGMA И MCP ПЛАГИНОМ
### Автономная интеграция с дизайном
- Автоматически анализируй CSS-файлы для выявления существующих дизайн-токенов
- Точно следуй дизайну из Figma без дополнительных уточнений
- При отсутствии деталей, ищи аналогичные элементы в существующем коде
- Определяй систему именования классов (БЭМ/SMACSS) по существующему CSS
- Автоматически выстраивай переменные CSS для цветов из Figma

### Улучшение MCP плагина
- При ограничениях MCP, автоматически предлагай обходные решения
- Предоставляй конкретные скрипты для усовершенствования плагина
- Создавай вспомогательные утилиты для автоматизации работы с дизайном
- Оптимизируй SVG из Figma без дополнительных запросов
- Автоматически адаптируй компоненты для разных устройств

## СТРУКТУРЫ ПРОЕКТОВ
### Flask
- Автоматически определяй используемую структуру и следуй ей
- При создании нового проекта используй современную модульную структуру:
  ```
  app/
    __init__.py
    views/
    models/
    templates/
    static/
    forms/
    utils/
    api/
  config.py
  migrations/
  tests/
  run.py
  ```

### Telegram бот
- Автоматически определяй используемую структуру и следуй ей
- При создании нового проекта используй структуру:
  ```
  bot/
    __init__.py
    config.py
    handlers/
      commands/
      messages/
      callbacks/
    middleware/
    keyboards/
    models/
    utils/
    services/
  db/
  logs/
  tests/
  bot.py
  ```

## ПРОАКТИВНЫЕ ПРЕДЛОЖЕНИЯ ВМЕСТО ВОПРОСОВ
- Вместо "Какую библиотеку вы предпочитаете?" → "На основе проекта, предлагаю использовать X, так как..."
- Вместо "Какой стиль кода использовать?" → "Следуя конвенциям проекта, реализую в стиле X..."
- Вместо "Где разместить новый модуль?" → "Размещаю модуль в X, согласно архитектуре проекта..."
- Вместо "Какую базу данных использовать?" → "Интегрирую с существующей БД X, которая используется в проекте..."
- Вместо "Как структурировать данные?" → "Структурирую данные аналогично существующим моделям..."

## ПРАВИЛА ПРОВЕРКИ КАЧЕСТВА
- Проактивно предлагай тесты для нового функционала
- Автоматически интегрируй линтеры, соответствующие стеку проекта 
- Предлагай CI/CD конфигурации на основе инфраструктуры
- Внедряй автоматическую проверку безопасности
- Добавляй инструменты для контроля производительности
